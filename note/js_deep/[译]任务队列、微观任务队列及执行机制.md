# 任务队列，微观任务队列及执行机制翻译

原文地址为：[Tasks, microtasks, queues and schedules](https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/)

感谢原作者~~~~~

提及的视频资料:

[great talk at JSConf on the event loop](https://www.youtube.com/watch?v=8aGhZQkoFbQ)

**翻译内容部分是译者补充，部分测试操作被译者写成了顺序分析，大概有50%属于自己添加的，如果有不对的地方，欢迎指出~ 邮箱 linjun911@gmail.com~**

## 总结(译注:由于原文实在是他喵的长，这里直接给出总结)

- 任务按顺序执行，浏览器可能在任务之间渲染页面

- 微观任务按顺序执行，并且在以下两种情况下执行:

  - 只要没有其他JS正在执行，并且在每个事件回调函数之后，微观任务就会执行

  - 在每个任务的结束阶段，微观任务会执行

希望你现在知道如何理解事件循环，至少知道执行的顺序。



## 正文

接下来进入正文:

思考题:

```javascript
console.log('script start');

setTimeout(function() {
  console.log('setTimeout');
}, 0);

Promise.resolve().then(function() {
  console.log('promise1');
}).then(function() {
  console.log('promise2');
});

console.log('script end');
```

输出的顺序是什么样呢？

```
script start
script end
promise1
promise2
setTimeout
```

正确的答案就是：script start，script end，promise1，promise2，setTimeout。 但并不是所有浏览器支持这样顺序的输出。

Edge/Firefox 40/ios safari和桌面版safari 8.0.8输出 setTimeout 在 promise1, promise2 之前 - 这里出现了顺序的竞争关系。这有点奇怪，因为在 Firefox39 和 Safari 8.0.7 上是没有这样的问题的。

## 为什么是这样的输出呢？

为了理解它，你需要知道事件循环是如何处理任务和微观任务的。第一次尝试理解它，可能会有很多的内容需要你记下来。深呼吸...

每个线程都有他们自己的事件循环，因此每个web worker都有自己的事件循环，这样它们才能独立执行，而所有来自同一来源的窗口共享同一事件循环，所以可以同步交流。事件循环持续的运行，执行所有被加入队列的任务。一个事件循环有多个任务来源，每个来源自身会确保任务执行的顺序(例如[IndexedDB自身的规范](http://w3c.github.io/IndexedDB/#database-access-task-source))，但是浏览器可以在循环的进行时，选择执行任务的来源。这就使得浏览器可以优先考虑执行用户体验更敏感的任务，比如用户输入。

任务会按照计划被执行，浏览器可以从它内部获取具体操作，放到JS/DOM的执行空间内，确保这些操作按顺序被执行。在任务之间，浏览器可能会更新渲染结果。从鼠标点击中得到的事件回调函数会安排一个任务，解析HTML也是，上面的 setTimeout 也一样。

setTimeout 在等待给定的延迟时间后会为它的回调函数安排一个任务。这就是为什么 setTimeout 的日志打印晚于 script end，打印 script end 是第一个任务的内容，而 setTimeout 在另一个任务中被打印。

微观任务是一些经常被安排在当前 sciprt 执行完毕后立即执行的事情，例如对一批行为做出反应(译注:代指DOM事件之类的)，或者是异步做一些事情(这些事情不需要单独分配一个新任务，比如 promise、ajax等)。只要没有其他的JS代码执行并且处于任务执行的结束时，微观任务就会被执行。任何在微观任务执行时被加入到微观任务队列尾部的微观任务也会被执行。微观任务包括 mutation 观察者回调，和上面的 promise 回调。

一旦 promise 解决，或者是它早已经被解决，就会为他的回调派发一个微观任务。这样可以确保 promise 的回调是异步执行的，即便 promise 早已经解决。所以对于一个已经解决的 promise 调用 .then(res, rej) 时会立刻派发一个微观任务。这就是为什么 promise1 和 promise2 会在 script end 后输出的原因，必须等待当前执行的 script 执行完毕后，微观任务才能执行。因为微观任务总是在下一个任务被执行前执行，所以 promise1 和 promise2 会在 setTimeout 前被输出。

所以，一步步来看:

```JavaScript
console.log('script start');

setTimeout(function() {
  console.log('setTimeout');
}, 0);

Promise.resolve().then(function() {
  console.log('promise1');
}).then(function() {
  console.log('promise2');
});
```

```
  step1
  // 执行console.log('script start')
  Tasks: **Run script**
  Microtasks:
  JS stack: **script**
  Log: **script start**

  step2
  // setTimeout为回调函数派发一个任务
  Tasks: **Run script** **setTimeout callback**
  Microtasks:
  JS stack: **script**
  Log: **script start**

  step3
  // Promise 为回调派发一个微观任务加入到微观任务队列中
  Tasks: **Run script** **setTimeout callback**
  Microtasks: **Promise then**
  JS stack: **script**
  Log: **script start**

  step4
  // 执行console.log('script end')
  Tasks: **Run script** **setTimeout callback**
  Microtasks: **Promise then**
  JS stack: **script**
  Log: **script start** **script end**

  step5
  // 当一个任务执行完毕时，我们开始执行微观任务
  // 执行Promise then
  Tasks: **Run script** **setTimeout callback**
  Microtasks: **Promise then**
  JS stack: **Promise callback**
  Log: **script start** **script end**

  step6
  // 当一个任务执行完毕时，我们开始执行微观任务
  // 执行Promise callback 打印 promise1 返回undefined
  // 下一个Promsie then派发成为微观任务 加入微观任务队列中
  Tasks: **Run script** **setTimeout callback**
  Microtasks: **Promise then** **Promise then**
  JS stack: **Promise callback**
  Log: **script start** **script end** **promise1**

  step7
  // 第一个微观任务 Promise then 执行完毕后，开始执行第二个微观任务
  // 执行Promise callback 打印 promise2 返回undefined
  Tasks: **Run script** **setTimeout callback**
  Microtasks: **Promise then**
  JS stack: **Promise callback**
  Log: **script start** **script end** **promise1** **promise2**

  step8
  // 微观任务执行完毕，微观任务队列为空，浏览器可能会更新页面渲染
  // 在上述流程完毕后，执行下一个任务 setTimeout callback
  // 输出 setTimeout
  Tasks: **setTimeout callback**
  Microtasks:
  JS stack: **setTimeout callback**
  Log: **script start** **script end** **promise1** **promise2** **setTimeout**

  step9
  // setTimeout callback执行完毕后，任务队列清空，执行栈清空
  Tasks:
  Microtasks:
  JS stack:
  Log: **script start** **script end** **promise1** **promise2** **setTimeout**
```

**注：译者并未从原文将动画搬过来，如果需要查看原文，点击箭头一步步尝试。**

### 有些浏览器做的不一样？

一些浏览器会打印 script start， script end， setTimeout， promise1， promise2。它们会在打印 setTimeout 后运行promise回调。看上去像是它们将 promise 回调当做了新任务的一部分而不是微观任务。

这是可以被原谅的，因为 promise 来源于 ECMAScript 而不是 HTML。ECMAScript 有"jobs"的概念类似于微观任务，但是它们的关系在[邮件讨论列表](https://esdiscuss.org/topic/the-initialization-steps-for-web-browsers#content-16)中被明确的区分开来。为了更好的理解，我们普遍认为promise应该是微观任务队列中的一部分。

将 promise 看做任务会导致一些性能问题，例如回调函数的执行可能会被本不需要的事情延后，比如说渲染。由于任务与其他任务源的交互，导致他们的执行充满不确定性，本应先执行的任务可能会在后面才执行。

这里有个关于让 Promise 使用微观任务的 Edge浏览器 的[ISSUE](https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/4091192/) (译注:在2017年5月edge团队同学已经发声解决了这个问题~)。WebKit内核一直做得很棒，所以我觉得safari很快就会修正这个事情，另外Firefox 43已经解决了这个问题。

有趣的是，safari和firefox都是从本已经解决这事儿，又回到了起点。我觉得应该只是一个巧合吧~~。

## 怎么获知事情是使用任务还是微观任务呢

测试是一种获知的方法。观察 promise 和 setTimeout 打印的相对时间，这样你依赖它而做的实现就会是正确的。

核心的方式，还是去查看规范的定义。说点实在的，setTimeout的第14步[译注:在新版html spec中已经改为了第18步](https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#timer-initialisation-steps)就是派发一个任务到任务队列里面，而 mutation observer 记录被添加的[第五步](https://dom.spec.whatwg.org/#queueing-a-mutation-record)就是派发一个微观任务加入到队列中。

在之前提过的，在 ECMAScript 中，它们称微观任务为'jobs'。在 PromiseThen 表现的第8步中，加入JOB就是派发一个微观任务。

现在，让我们看看更多的示例。别管那些'浏览器还没准备好呢！！'的言词，让我们一起来尝试下...

## 初级BOSS战~

这是html的部分:

```html
<div class="outer">
  <div class="inner"></div>  
</div>
```

下面是js的部分，当我们点击 div.inner 时，将会怎么打印呢？

```JavaScript
  var outer = document.querySelector('.outer')
  var inner = document.querySelector('.inner')

  // 监听元素上的属性改动
  new MutationObserver(function () {
    console.log('mutate');
  }).observe(outer, {
    attributes: true
  })

  function onClick() {
    console.log('click');

    setTimeout(function () {
      console.log(timeout);
    }, 0);

    Promsie.resolve().then(function () {
      console.log('promise')
    })

    outer.setAttribute('data-random', Math.random())
  }

  inner.addEventListener('click', onClick);
  outer.addEventListener('click', onClick);
```

你可以在给出答案前，先试试~

## 结果是:

```bash
  click
  promise
  mutate
  click
  promise
  mutate
  timeout
  timeout
```

和你猜测的不同么？如果不同，你可能还是对的呢~。原因在于浏览器“们”不是都这样输出的。。

![2015年的输出情况](https://github.com/evanzlj/self-learn/raw/dev/note/js_deep/imgs/browser_log.jpeg)

## 谁是对的？

一个'click'事件其实是派发了一个任务。Mutation observer 和 promise 回调都是派发微观任务。setTimeout 回调会派发任务。所以正确的输出路径应该是

```bash
<!-- step1 触发click事件 -->
<!-- onClick回调被加入到执行栈中 -->
Tasks: **Dispatch Click**
Microtasks:
JS Stack: **onClick**
Log:

<!-- step2 onClick回调执行 -->
<!-- 输出 click ， 将 setTimeout 放入浏览器的Timer容器中计数等待，
Promise.then回调被加入到微观任务中-->
<!-- 到达最小延迟4ms后，setTimeout 回调派发任务到任务队列中 -->
<!-- 设置outer元素的data-random属性，触发 mutation 的监听 -->
<!-- mutation回调加入到微观任务队列中 -->
Tasks: **Dispatch Click** **setTimeout**
Microtasks: **Promise.then** **mutation observer**
JS Stack: **onClick**
Log: **click**

<!-- step3 onClick回调执行完毕 -->
<!-- onClick出JS执行栈，Promise Then压入执行栈(根据上面我们讨论的微观任务执行机制) -->
Tasks: **Dispatch Click** **setTimeout**
Microtasks: **Promise.then** **mutation observer**
JS Stack: **Promise.then callback**
Log: **click**

<!-- step3.1 执行Promise then 回调 输出promsie，promise then出栈-->
Tasks: **Dispatch Click** **setTimeout**
Microtasks: **Promise.then** **mutation observer**
JS Stack:
Log: **click** **promise**

<!-- step3.2 压入 Mutation observer 回调到JS执行栈-->
Tasks: **Dispatch Click** **setTimeout**
Microtasks: **mutation observer**
JS Stack: **Mutation observer callback**
Log: **click** **promise**

<!-- step3.3 执行Mutation 回调，输出 mutate-->
<!-- Mutation出栈 -->
Tasks: **Dispatch Click** **setTimeout**
Microtasks:
JS Stack:
Log: **click** **promise** **mutate**

<!-- step4 由于事件冒泡，click 事件执行outer上的回调-->
<!-- onClick回调压入js执行栈 -->
Tasks: **Dispatch Click** **setTimeout**
Microtasks:
JS Stack: **onClick callback**
Log: **click** **promise** **mutate**

<!-- step5 重复第一次的click回调处理-->
<!-- 打印 click -->
<!-- 加入新的setTimeout任务 -->
<!-- 派发promise.then / mutation observer 到微观任务队列 -->
Tasks: **Dispatch Click** **setTimeout** **setTimeout**
Microtasks: **promise.then** **mutation observer**
JS Stack: **onClick callback**
Log: **click** **promise** **mutate** **click**

<!-- step6 onClick出栈 开始执行微观任务队列中的项 -->
<!-- 顺序执行微观任务，打印 promise 、mutate -->
Tasks: **Dispatch Click** **setTimeout** **setTimeout**
Microtasks:
JS Stack:
Log: **click** **promise** **mutate** **click** **promise** **mutate**

<!-- step7 Dispatch Click出任务队列，执行setTimeout回调 -->
Tasks: **setTimeout** **setTimeout**
Microtasks:
JS Stack: **setTimeout callback**
Log: **click** **promise** **mutate** **click** **promise** **mutate**

<!-- step8 执行回调输出 timeout -->
<!-- 第一个setTimeout出队列，由于没有微观任务，第二个也是如此执行即可 -->
Tasks: **setTimeout**
Microtasks:
JS Stack: **setTimeout callback**
Log: **click** **promise** **mutate** **click** **promise** **mutate** **timeout**

<!-- Finally -->
Tasks:
Microtasks:
JS Stack:
Log: **click** **promise** **mutate** **click** **promise** **mutate** **timeout** **timeout**
```

所以 Chrome 的顺序是正确的。这个例子使我意识到了一个新的事情，微观任务是在DOM事件回调完毕后执行的(只要没有其他 js 代码在执行)，我认为它受制于"一个任务结束前的才被执行"这一规则。这个调用回调的规则来自于HTML规范:

> If the stack of script settings objects is now empty, perform a microtask checkpoint

> — [HTML: Cleaning up after a callback step 3](https://html.spec.whatwg.org/multipage/webappapis.html#clean-up-after-running-a-callback)

...而一个微观任务的执行点是在经过微观任务队列时，除非我们已经在执行微观任务队列。类似的，ECMAScript 是这样描述Jobs的:

> Execution of a Job can be initiated only when there is no running execution context and the execution context stack is empty…

> - [ECMAScript: Jobs and Job Queues](http://www.ecma-international.org/ecma-262/6.0/#sec-jobs-and-job-queues)

根据上面的描述可以看出，在HTML上下文中，仅仅是把ECMAScript中的 “can be” 改成了 “must be”。

## 这些浏览器在哪个步骤有问题呢？

Firefox 和 Safari 正确地在两次click监听执行期间执行了微观队列，如微观任务 mutation 回调展示的一样，但是 primises 被加入队列的表现是有问题的。这是可以原谅的，jobs 和 microtasks 之间的联系是毕竟没有确定，但我仍希望他们在监听器回调之间执行。[Firefox ticket](https://bugzilla.mozilla.org/show_bug.cgi?id=1193394)。[Safari ticket](https://bugs.webkit.org/show_bug.cgi?id=147933)。

对于 Edge ，我们已经观察到了在它里面 promise 进入的队列是不对的，但是它也没有在两个 click 事件监听回调间执行微观任务队列，直到所有 click 事件监听回调被调用完毕之后，它才开始执行微观任务队列，这导致在所有 click 被打印出来之后，只有一个 mutate 打印出来。[Bug ticket](https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/5332667/)(译注:补充下，mutation observer的同一回调只能存在一个，这跟 mutation 使用的记录方式有关，[详参](https://dom.spec.whatwg.org/#mutation-observers))

## 初级BOSS的老哥

继续使用上面的例子，但是现在这么触发:

```javascript
inner.click();
```

和之前一样的安排事件，但是使用脚本触发而不是真实的交互。

## 尝试下

```bash
  click
  click
  promise
  mutate
  promise
  timeout
  timeout
```

这回浏览器们的表现是:

![在boss他哥的执行下](https://github.com/evanzlj/self-learn/raw/dev/note/js_deep/imgs/browser_log1.jpeg)

我从chrome中得到过不同的答案，我更新这个表的时候，认为不应该用 Chrome Canary 进行测试。如果你在 Chrome 中得到不同的答案，请在评论中告诉我是哪个版本的浏览器。

## 为啥不一样呢？

```JavaScript
// Let's get hold of those elements
var outer = document.querySelector('.outer');
var inner = document.querySelector('.inner');

// Let's listen for attribute changes on the
// outer element
new MutationObserver(function() {
  console.log('mutate');
}).observe(outer, {
  attributes: true
});

// Here's a click listener…
function onClick() {
  console.log('click');

  setTimeout(function() {
    console.log('timeout');
  }, 0);

  Promise.resolve().then(function() {
    console.log('promise');
  });

  outer.setAttribute('data-random', Math.random());
}

// …which we'll attach to both elements
inner.addEventListener('click', onClick);
outer.addEventListener('click', onClick);

inner.click()
```

它的执行应该是这样的：

```bash
<!-- step1 执行脚本 -->
Tasks: ***Run script*
Microtasks:
JS Stack: **script**
Log:

<!-- step2 一直执行到 inner.click() 部分 -->
<!-- 触发inner上的click事件回调，压入执行栈中 -->
Tasks: ***Run script*
Microtasks:
JS Stack: **script** **onClick**
Log:

<!-- step3 执行onClick内的内容 -->
<!-- 打印 click -->
<!-- 将 setTimeout 压入任务队列 -->
<!-- Promise.then 压入微观任务队列 -->
<!-- 触发mutation observer 压入微观任务队列-->
Tasks: **Run script** **setTimeout callback**
Microtasks: **Promise.then** **mutation observer callback**
JS Stack: **script** **onClick**
Log: **click**

<!-- step4 inner的Click callback出栈 -->
<!-- 但是js执行栈内还有 script 存在，所以不能执行微观任务队列 -->
Tasks: **Run script** **setTimeout callback**
Microtasks: **Promise.then** **mutation observer callback**
JS Stack: **script**
Log: **click**

<!-- step5 inner的click事件引起冒泡，触发了outer元素上的 click 回调 -->
<!-- click回调加入执行栈中 -->
Tasks: **Run script** **setTimeout callback**
Microtasks: **Promise.then** **mutation observer callback**
JS Stack: **script** **outer Click callback**
Log: **click**

<!-- step6 inner的click事件引起冒泡，触发了outer元素上的 click 回调 -->
<!-- click回调加入执行栈中 -->
Tasks: **Run script** **setTimeout callback**
Microtasks: **Promise.then** **mutation observer callback**
JS Stack: **script** **outer Click callback**
Log: **click**

<!-- step7 回调执行 -->
<!-- 打印 click -->
<!-- 将 setTimeout 加入到任务队列 -->
<!-- 将 Promise.then 加入到微观任务队列 -->
<!-- 由于mutation observer callback只能有一个存在，所以新触发的那个回调不会加入到围观队列中！！！！ -->
Tasks: **Run script** **setTimeout callback** **setTimeout callback**
Microtasks: **Promise.then** **mutation observer callback** **Promise.then**
JS Stack: **script** **outer Click callback**
Log: **click** **click**

<!-- step8 事件回调执行完毕，script 执行完毕，依次出栈 -->
<!-- 检测到第一个任务 Run script进入结束阶段，微观任务队列开始执行 -->
<!-- Promise.then 回调加入到执行栈中 -->
Tasks: **Run script** **setTimeout callback** **setTimeout callback**
Microtasks: **Promise.then** **mutation observer callback** **Promise.then**
JS Stack: **Promise.then callback**
Log: **click** **click**

<!-- step9 执行promise.then回调 -->
<!-- 输出 promise -->
Tasks: **Run script** **setTimeout callback** **setTimeout callback**
Microtasks: **Promise.then** **mutation observer callback** **Promise.then**
JS Stack: **Promise.then callback**
Log: **click** **click** **promsie**

<!-- step9 promise.then出栈出队列，mutation observer callback 入栈 -->
Tasks: **Run script** **setTimeout callback** **setTimeout callback**
Microtasks: **mutation observer callback** **Promise.then**
JS Stack: **mutation observer callback**
Log: **click** **click** **promsie**

<!-- step10 mutation observer callback执行 -->
<!-- 输出 mutate -->
Tasks: **Run script** **setTimeout callback** **setTimeout callback**
Microtasks: **mutation observer callback** **Promise.then**
JS Stack: **mutation observer callback**
Log: **click** **click** **promsie** **mutate**

<!-- step11 mutation observer callback 出栈出队列，promise.then callback 入栈 -->
Tasks: **Run script** **setTimeout callback** **setTimeout callback**
Microtasks: **Promise.then**
JS Stack: **Promise.then callback**
Log: **click** **click** **promsie** **mutate**

<!-- step12 promise.then callback执行 -->
<!-- 输出 promise -->
Tasks: **Run script** **setTimeout callback** **setTimeout callback**
Microtasks: **Promise.then**
JS Stack: **Promise.then callback**
Log: **click** **click** **promsie** **mutate** **promsie**

<!-- step13 promise.then callback 出栈出队列 -->
Tasks: **Run script** **setTimeout callback** **setTimeout callback**
Microtasks:
JS Stack:
Log: **click** **click** **promsie** **mutate** **promsie**

<!-- step14 微观任务清空，且第一个任务 Run script 结束 -->
<!-- 执行下一个任务 setTimeout，进入执行栈 -->
Tasks: **setTimeout callback** **setTimeout callback**
Microtasks:
JS Stack: **setTimeout callback**
Log: **click** **click** **promsie** **mutate** **promsie**

<!-- step15 setTimeout callback执行 -->
<!-- 输出 timeout -->
Tasks: **setTimeout callback** **setTimeout callback**
Microtasks:
JS Stack:  **setTimeout callback**
Log: **click** **click** **promsie** **mutate** **promsie** **timeout**

<!-- step16 setTimeout callback出栈，没有微观任务，直接进入到下一个setTimeout任务 -->
Tasks: **setTimeout callback**
Microtasks:
JS Stack: **setTimeout callback**
Log: **click** **click** **promsie** **mutate** **promsie** **timeout**

<!-- finnaly -->
Tasks:
Microtasks:
JS Stack:
Log: **click** **click** **promsie** **mutate** **promsie** **timeout** **timeout**
```

所以正确的顺序是 click click promise mutate promise timeout timeout，恩，chrome是对的。

> If the stack of script settings objects is now empty, perform a microtask checkpoint

> — [HTML: Cleaning up after a callback step 3](https://html.spec.whatwg.org/multipage/webappapis.html#clean-up-after-running-a-callback)

前面提过，微观任务会在事件监听回调之间执行，但是如果 .click() 导致事件的触发是同步执行的话，那么 script 任务会被 .click() 吊起执行的回调函数压在执行栈中。上面的规则确保微观任务不会打断JS执行。这就意味着，我们不能在事件监听回调之间执行，它们会晚于回调函数执行。

## 这样有什么问题？(译注:以下为indexDB调用时的场景，可以忽略不计，上述已经完整介绍了浏览器中的事件循环和执行机制。退后，下面我将开始装逼)

当然有，它会在一些不显眼的地方坑你。我当时尝试为 IndexedDB 创建一个使用 Promise 而不是 IDBRequest objects 的包装函数库。他能更方便的使用 IDB 。

当 IDB 触发了一个成功的事件时，相关的事务对象就会在派发后变成不活跃状态。如果我创建一个promise，他可以在事件出发时就解析，这个回调应该就会在第4步之前执行，而事务依然可以保持活跃，但是除了Chrome，其他的浏览器都不支持这样的行为，这个库没有起作用。

你可以在Firefox上尝试下这个问题，因为promise的垫板库例如 es6-promise 对回调函数使用了 Mutation Observer，它可以正确的使用微观任务队列。safari的修复还处于不确定的状态，那可能是源于它们糟糕的 IDB 实现吧。而 IE/Edge 就更不行了，mutation 还没有在回调函数之后执行。

希望我们能很快看到这些修复吧。

## 尾

还有人在看么~~~~~ 点个赞呗。

**自此，浏览器和node下的事件循环机制，我就探索完毕了，里面更细节的部分，我会逐渐看规范，有更新会及时放到文章中。也请各位同学提出自己的问题，我会努力帮你解答，十分感谢！**
