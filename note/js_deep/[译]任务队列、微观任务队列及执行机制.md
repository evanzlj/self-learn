# 任务队列，微观任务队列及执行机制翻译

原文地址为：[Tasks, microtasks, queues and schedules](https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/)

提及的视频资料:

[great talk at JSConf on the event loop](https://www.youtube.com/watch?v=8aGhZQkoFbQ)

**翻译内容部分是译者补充，部分测试操作被译者写成了顺序分析，如果有不对的地方，欢迎指出~ 邮箱 linjun911@gmail.com~**

接下来进入正文:

思考题:

```javascript
console.log('script start');

setTimeout(function() {
  console.log('setTimeout');
}, 0);

Promise.resolve().then(function() {
  console.log('promise1');
}).then(function() {
  console.log('promise2');
});

console.log('script end');
```

输出的顺序是什么样呢？

```
script start
script end
promise1
promise2
setTimeout
```

正确的答案就是：script start，script end，promise1，promise2，setTimeout。 但并不是所有浏览器支持这样顺序的输出。

Edge/Firefox 40/ios safari和桌面版safari 8.0.8输出 setTimeout 在 promise1, promise2 之前 - 这里出现了顺序的竞争关系。这有点奇怪，因为在 Firefox39 和 Safari 8.0.7 上是没有这样的问题的。

## 为什么是这样的输出呢？

为了理解它，你需要知道事件循环是如何处理任务和微观任务的。第一次尝试理解它，可能会有很多的内容需要你记下来。深呼吸...

每个线程都有他们自己的事件循环，因此每个web worker都有自己的事件循环，这样它们才能独立执行，而所有来自同一来源的窗口共享同一事件循环，所以可以同步交流。事件循环持续的运行，执行所有被加入队列的任务。一个事件循环有多个任务来源，每个来源自身会确保任务执行的顺序(例如[IndexedDB自身的规范](http://w3c.github.io/IndexedDB/#database-access-task-source))，但是浏览器可以在循环的进行时，选择执行任务的来源。这就使得浏览器可以优先考虑执行用户体验更敏感的任务，比如用户输入。

任务会按照计划被执行，浏览器可以从它内部获取具体操作，放到JS/DOM的执行空间内，确保这些操作按顺序被执行。在任务之间，浏览器可能会更新渲染结果。从鼠标点击中得到的事件回调函数会安排一个任务，解析HTML也是，上面的 setTimeout 也一样。

setTimeout 在等待给定的延迟时间后会为它的回调函数安排一个任务。这就是为什么 setTimeout 的日志打印晚于 script end，打印 script end 是第一个任务的内容，而 setTimeout 在另一个任务中被打印。

微观任务是一些经常被安排在当前 sciprt 执行完毕后立即执行的事情，例如对一批行为做出反应(译注:代指DOM事件之类的)，或者是异步做一些事情(这些事情不需要单独分配一个新任务，比如 promise、ajax等)。只要没有其他的JS代码执行并且处于任务执行的结束时，微观任务就会被执行。任何在微观任务执行时被加入到微观任务队列尾部的微观任务也会被执行。微观任务包括 mutation 观察者回调，和上面的 promise 回调。

一旦 promise 解决，或者是它早已经被解决，就会为他的回调派发一个微观任务。这样可以确保 promise 的回调是异步执行的，即便 promise 早已经解决。所以对于一个已经解决的 promise 调用 .then(res, rej) 时会立刻派发一个微观任务。这就是为什么 promise1 和 promise2 会在 script end 后输出的原因，必须等待当前执行的 script 执行完毕后，微观任务才能执行。因为微观任务总是在下一个任务被执行前执行，所以 promise1 和 promise2 会在 setTimeout 前被输出。

所以，一步步来看:

```JavaScript
console.log('script start');

setTimeout(function() {
  console.log('setTimeout');
}, 0);

Promise.resolve().then(function() {
  console.log('promise1');
}).then(function() {
  console.log('promise2');
});
```

```
  step1
  // 执行console.log('script start')
  Tasks: **Run script**
  Microtasks:
  JS stack: **script**
  Log: **script start**

  step2
  // setTimeout为回调函数派发一个任务
  Tasks: **Run script** **setTimeout callback**
  Microtasks:
  JS stack: **script**
  Log: **script start**

  step3
  // Promise 为回调派发一个微观任务加入到微观任务队列中
  Tasks: **Run script** **setTimeout callback**
  Microtasks: **Promise then**
  JS stack: **script**
  Log: **script start**

  step4
  // 执行console.log('script end')
  Tasks: **Run script** **setTimeout callback**
  Microtasks: **Promise then**
  JS stack: **script**
  Log: **script start** **script end**

  step5
  // 当一个任务执行完毕时，我们开始执行微观任务
  // 执行Promise then
  Tasks: **Run script** **setTimeout callback**
  Microtasks: **Promise then**
  JS stack: **Promise callback**
  Log: **script start** **script end**

  step6
  // 当一个任务执行完毕时，我们开始执行微观任务
  // 执行Promise callback 打印 promise1 返回undefined
  // 下一个Promsie then派发成为微观任务 加入微观任务队列中
  Tasks: **Run script** **setTimeout callback**
  Microtasks: **Promise then** **Promise then**
  JS stack: **Promise callback**
  Log: **script start** **script end** **promise1**

  step7
  // 第一个微观任务 Promise then 执行完毕后，开始执行第二个微观任务
  // 执行Promise callback 打印 promise2 返回undefined
  Tasks: **Run script** **setTimeout callback**
  Microtasks: **Promise then**
  JS stack: **Promise callback**
  Log: **script start** **script end** **promise1** **promise2**

  step8
  // 微观任务执行完毕，微观任务队列为空，浏览器可能会更新页面渲染
  // 在上述流程完毕后，执行下一个任务 setTimeout callback
  // 输出 setTimeout
  Tasks: **setTimeout callback**
  Microtasks:
  JS stack: **setTimeout callback**
  Log: **script start** **script end** **promise1** **promise2** **setTimeout**

  step9
  // setTimeout callback执行完毕后，任务队列清空，执行栈清空
  Tasks:
  Microtasks:
  JS stack:
  Log: **script start** **script end** **promise1** **promise2** **setTimeout**
```

**注：译者并未从原文将动画搬过来，如果需要查看原文，点击箭头一步步尝试。**

### 有些浏览器做的不一样？

一些浏览器会打印 script start， script end， setTimeout， promise1， promise2。它们会在打印 setTimeout 后运行promise回调。看上去像是它们将 promise 回调当做了新任务的一部分而不是微观任务。

这是可以被原谅的，因为 promise 来源于 ECMAScript 而不是 HTML。ECMAScript 有"jobs"的概念类似于微观任务，但是它们的关系在[邮件讨论列表](https://esdiscuss.org/topic/the-initialization-steps-for-web-browsers#content-16)中被明确的区分开来。为了更好的理解，我们普遍认为promise应该是微观任务队列中的一部分。

将 promise 看做任务会导致一些性能问题，例如回调函数的执行可能会被本不需要的事情延后，比如说渲染。由于任务与其他任务源的交互，导致他们的执行充满不确定性，本应先执行的任务可能会在后面才执行。

这里有个关于让 Promise 使用微观任务的 Edge浏览器 的[ISSUE](https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/4091192/) (译注:在2017年5月edge团队同学已经发声解决了这个问题~)。WebKit内核一直做得很棒，所以我觉得safari很快就会修正这个事情，另外Firefox 43已经解决了这个问题。

有趣的是，safari和firefox都是从本已经解决这事儿，又回到了起点。我觉得应该只是一个巧合吧~~。

## 怎么获知事情是使用任务还是微观任务呢

测试是一种获知的方法。观察 promise 和 setTimeout 打印的相对时间，这样你依赖它而做的实现就会是正确的。

核心的方式，还是去查看规范的定义。说点实在的，setTimeout的第14步[译注:在新版html spec中已经改为了第18步](https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#timer-initialisation-steps)就是派发一个任务到任务队列里面，而 mutation observer 记录被添加的[第五步](https://dom.spec.whatwg.org/#queueing-a-mutation-record)就是派发一个微观任务加入到队列中。

在之前提过的，在 ECMAScript 中，它们称微观任务为'jobs'。在 PromiseThen 表现的第8步中，加入JOB就是派发一个微观任务。

现在，让我们看看更多的示例。别管那些'浏览器还没准备好呢！！'的言词，让我们一起来尝试下...

## 初级BOSS战~

这是html的部分:

```html
<div class="outer">
  <div class="inner"></div>  
</div>
```

下面是js的部分，当我们点击 div.inner 时，将会怎么打印呢？

```JavaScript
  var outer = document.querySelector('.outer')
  var inner = document.querySelector('.inner')

  // 监听元素上的属性改动
  new MutationObserver(function () {
    console.log('mutate');
  }).observe(outer, {
    attributes: true
  })

  function onClick() {
    console.log('click');

    setTimeout(function () {
      console.log(timeout);
    }, 0);

    Promsie.resolve().then(function () {
      console.log('promise')
    })

    outer.setAttribute('data-random', Math.random())
  }

  inner.addEventListener('click', onClick);
  outer.addEventListener('click', onClick);
```

你可以在给出答案前，先试试~

## 结果是:

```bash
  click
  promise
  mutate
  click
  promise
  mutate
  timeout
  timeout
```

和你猜测的不同么？如果不同，你可能还是对的呢~。原因在于浏览器“们”不是都这样输出的。。

![2015年的输出情况](https://github.com/evanzlj/self-learn/raw/dev/note/js_deep/imgs/brower_log.jpeg)

## 谁是对的？

一个'click'事件其实是派发了一个任务。Mutation observer 和 promise 回调都是派发微观任务。setTimeout 回调会派发任务。所以正确的输出路径应该是

```
<!-- step1 触发click事件 -->
<!-- onClick回调被加入到执行栈中 -->
Tasks: **Dispatch Click**
Microtasks:
JS Stack: **onClick**
Log:

<!-- step2 onClick回调执行 -->
<!-- 输出 click ， 将 setTimeout 放入浏览器的Timer容器中计数等待，
Promise.then回调被加入到微观任务中-->
<!-- 到达最小延迟4ms后，setTimeout 回调派发任务到任务队列中 -->
<!-- 设置outer元素的data-random属性，触发 mutation 的监听 -->
<!-- mutation回调加入到微观任务队列中 -->
Tasks: **Dispatch Click** **setTimeout**
Microtasks: **Promise.then** **mutation observer**
JS Stack: **onClick**
Log: **click**

<!-- step3 onClick回调执行完毕 -->
<!-- onClick出JS执行栈，Promise Then压入执行栈(根据上面我们讨论的微观任务执行机制) -->
Tasks: **Dispatch Click** **setTimeout**
Microtasks: **Promise.then** **mutation observer**
JS Stack: **Promise.then callback**
Log: **click**

<!-- step3.1 执行Promise then 回调 输出promsie，promise then出栈-->
Tasks: **Dispatch Click** **setTimeout**
Microtasks: **Promise.then** **mutation observer**
JS Stack:
Log: **click** **promise**

<!-- step3.2 压入 Mutation observer 回调到JS执行栈-->
Tasks: **Dispatch Click** **setTimeout**
Microtasks: **mutation observer**
JS Stack: **Mutation observer callback**
Log: **click** **promise**

<!-- step3.3 执行Mutation 回调，输出 mutate-->
<!-- Mutation出栈 -->
Tasks: **Dispatch Click** **setTimeout**
Microtasks:
JS Stack:
Log: **click** **promise** **mutate**

<!-- step4 由于事件冒泡，click 事件执行outer上的回调-->
<!-- onClick回调压入js执行栈 -->
Tasks: **Dispatch Click** **setTimeout**
Microtasks:
JS Stack: **onClick callback**
Log: **click** **promise** **mutate**

<!-- step5 重复第一次的click回调处理-->
<!-- 打印 click -->
<!-- 加入新的setTimeout任务 -->
<!-- 派发promise.then / mutation observer 到微观任务队列 -->
Tasks: **Dispatch Click** **setTimeout** **setTimeout**
Microtasks: **promise.then** **mutation observer**
JS Stack: **onClick callback**
Log: **click** **promise** **mutate** **click**

<!-- step6 onClick出栈 开始执行微观任务队列中的项 -->
<!-- 顺序执行微观任务，打印 promise 、mutate -->
Tasks: **Dispatch Click** **setTimeout** **setTimeout**
Microtasks:
JS Stack:
Log: **click** **promise** **mutate** **click** **promise** **mutate**

<!-- step7 Dispatch Click出任务队列，执行setTimeout回调 -->
Tasks: **setTimeout** **setTimeout**
Microtasks:
JS Stack: **setTimeout callback**
Log: **click** **promise** **mutate** **click** **promise** **mutate**

<!-- step8 执行回调输出 timeout -->
<!-- 第一个setTimeout出队列，由于没有微观任务，第二个也是如此执行即可 -->
Tasks: **setTimeout**
Microtasks:
JS Stack: **setTimeout callback**
Log: **click** **promise** **mutate** **click** **promise** **mutate** **timeout**

<!-- Finally -->
Tasks:
Microtasks:
JS Stack:
Log: **click** **promise** **mutate** **click** **promise** **mutate** **timeout** **timeout**
```

所以 Chrome 的顺序是正确的。这个例子使我意识到了一个新的事情，微观任务是在DOM事件回调完毕后执行的(只要没有其他 js 代码在执行)，我认为它受制于"一个任务结束前的才被执行"这一规则。这个调用回调的规则来自于HTML规范:
